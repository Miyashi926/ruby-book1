正規表現　メモ

その1
本記事では正規表現を利用した電話番号の検索を通じて、正規表現に関する以下のような知識を学びます。

「パターンを指定して、文字列を効率よく検索・置換するためのミニ言語」
\d は正規表現では特別な意味を持ちます。　　こういった特別な文字を 「メタ文字」 と呼びます。
\d は「1個の半角数字（0123456789）」を意味するメタ文字です（文字の集合を表しているので、特に 「文字クラス」 と呼ばれます）
正規表現では \d は「1個の半角数字」を検索します。

/\d\d-\d\d\d\d-\d\d\d\d/g の最後の g はグローバルオプションと呼ばれるもので、以下のような違いがあります。
g なし => 最初の1件が見つかったら検索終了
g あり => 一致する文字列をすべて抽出

正規表現を使うときは、最初に検索対象文字列の 「法則（パターン）」 をうまく見つけだすのが大切です。
文字の個数を限定するときは {n,m} や {n} というメタ文字を使います（文字量を指定するので、特に 「量指定子」 と呼ばれます）。
{n,m} は「直前の文字が n 個以上、m 個以下」の意味です。
また、 {n} とすれば「ちょうど n 文字」の意味になります。
正規表現では { と } もやはり特別な意味を持つことを覚えておいてください。


「AまたはBのいずれか1文字」表す場合は [AB] と書きます（文字の集合を表すので、これも 文字クラス の一種です）
[ ]の中の文字数に制限はありません。
[ABC] と書けば、「AまたはBまたはCのいずれか1文字」の意味になります。

ハイフンまたはカッコ（開き）と、ハイフンまたはカッコ（閉じ）はそれぞれ、[-(]、[-)] と表現します。
記号だけが並んでいてちょっとわかりづらいですが、 [AB] の形式になっていることを確認してください。

ちなみに今回出てきた半角の丸カッコ（ ( と ) ）は、[ ] の外で使われると特別な意味を持ちます。

[ ] 中のハイフンは注意が必要
先ほどの正規表現では [-(] や [-)] と書いて「ハイフンまたはカッコ（開き）」と「ハイフンまたはカッコ（閉じ）」を表現しました。
一般的に [AB] は [BA] と書いても同じ動きになります。
ただし、- だけは特別な意味を持つので注意が必要です。
実は [a-z] と書くと、「aまたはbまたはcまたは・・・yまたはz」の意味になるのです。
「aまたはハイフンまたはz」ではありません！
[a-zA-Z0-9] であれば「aまたはbまたは・・・z、AまたはBまたは・・・Z、0または1または・・・9」の意味になります。（端的に言うと、これは「半角英数字1文字」の意味です）
つまり、[a-z] のようなのハイフンは「文字の範囲」を意味します。
ただし、[-az] や [az-] のように、ハイフンが [ ] の最初、または最後に置かれると「ハイフン1文字」の意味に変わります。
なので [-az] や [az-] は「aまたはzまたはハイフンのいずれか1文字」の意味になります。

検索の精度と正規表現の複雑さについて
現実的には「100%完璧ではなく、そこそこ正しいレベルの正規表現」で妥協することがよくあります。
そして、「そこそこ正しい」の度合いは要件によって変わってきます。


まとめ
本記事では正規表現について以下のようなことを学びました。

\d は「半角数字1文字」を表す
{n,m} は「直前の文字が n 文字以上、m 文字以下」であることを表す
{n} は「直前の文字がちょうど n 文字」であることを表す
[AB] は「AまたはBが1文字」であることを表す
[a-z] と [-az] ではハイフンの意味が異なる
正規表現の正確さと複雑さはトレードオフになることが多い







その２
本記事では表記の揺れを許容した検索と、HTMLタグからCSVへの置換処理を通じて、正規表現に関する以下のような知識を学びます。

区切り文字の有無を許容する
区切り文字が1文字、 もしくは区切り無し 」というパターンです。
今回のように 「～が1文字、または無し」を表現するためには ? というメタ文字を使います。（文字量を指定するので 量指定子 のひとつです）

正規表現にはちょうど「任意の1文字」を表す . （カンマ）　というメタ文字（文字クラス）があります。

HTMLタグをCSVへ変換する
正規表現は検索だけでなく、置換する場合にも非常に便利です。
HTML/XMLパーサを使って変換プログラムを書くという手もありますが、ある程度パターンが決まっているケースであれば、正規表現を使って置換してしまう方が速いかもしれません。


「直前の文字が 1文字以上 」を表す場合は + というメタ文字（量指定子）を使います。
「英数字またはアンダースコア」は [a-z0-9_] のように [ ] と - を使って書けます

バックスラッシュ（\）はスラッシュ（/）をエスケープするためのエスケープ文字です。
RubyやJavaScriptでは /abc/ のようにスラッシュを使って正規表現オブジェクトを作るので、正規表現中に出てくるスラッシュはエスケープする必要があります。

正規表現に ( ) を使うと、その部分がキャプチャ（捕捉）され、連番が付けられるのです。

$1 と $2 はそれぞれキャプチャされた1番目の文字列と2番目の文字列を表しています。
つまり、$1,$2 はマッチした文字列を value,表示テキスト の文字列に置換していることになるわけです。

表示テキストがないoptionも置換できるようにする
「直前の文字が0文字以上」を表す場合は * というメタ文字（量指定子）を使います。

selectedになっているoptionも置換できるようにする
A? のような正規表現は「Aがあり、または無し」の意味でしたが、実はメタ文字の ? は2文字以上の文字列に対しても使えます。
ただしその場合は対象となる文字列を ( ) で囲みます。（ グループ化 といいます）
具体的には (ABC)? のように書くと、「文字列 ABC があり、または無し」の意味になります。
キャプチャする必要がない ( ) は (?: ) のように、?: をつけてやります。

正規表現には \w というメタ文字があります。 英単語を構成する文字」の意味です
RubyやJavaScriptでは「\w = [a-zA-Z0-9_]（半角英数字とアンダースコア1文字） 」という仕様になっています。

Rubyで置換してみる
キャプチャされた文字列を $1 ではなく \1 で参照しているのが異なる点です。

重要： * と + は「貪欲」であることに注意！
ところで、今回紹介した * と + は扱い方を間違えると ドツボにハマります。

解決策１：「任意の1文字」よりも厳しい条件を指定する
「 A以外の 任意の文字」を表す場合は [^A] と書きます。
[ ] の最初に ^ が入ると否定の意味に変わるのです。
[^AB] であれば「AでもなくBでもない任意の1文字」の意味になります。
よって、「< 以外の任意の文字」を表す場合は [^<] と書きます。

解決策２：最短のマッチを返すように指定する
>(.*)< の意味をもう少し厳密に書くと以下のようになります。
「> で始まり、任意の文字が0個以上連続し（.*）、 最後に見つかった < で終わる」
今回のケースはこれを次のように変えればうまくいくはずです。
「> で始まり、任意の文字が0個以上連続し（.*）、 最初に見つかった < で終わる」
こうするためには >(.*?)< のように ? を付けます。
*? や +? にすると最長ではなく、最短のマッチを結果として返すようになるのです（これを 最小量指定子 と呼びます）。
ただし、実行環境によっては *? や +? を使えないケースがあります（JavaScriptやAtomでは使えます）。
その場合は解決策１で紹介した、[^<]* のような否定条件の正規表現を使ってください。
ちなみに、* や + が「貪欲なマッチ」と呼ばれるのに対して、*? や +? は「 控えめなマッチ 」と呼ばれることがあります。

注意：ミスが許されない置換は1個ずつ確認しながら実行しましょう

まとめ
? は「直前の文字が1個、または無し」を表す
. は「任意の1文字」を表す
+ は「直前の文字が1個以上」を表す
* は「直前の文字が0個以上」を表す
( ) はマッチする部分をキャプチャ（捕捉）する
キャプチャした部分は置換するときに $1 や \1 <=ruby で参照できる
\w は「英単語を構成する文字（半角英数字とアンダースコア）」を表す
[^AB] は「AでもなくBでもない任意の1文字」を表す
正規表現中の特別な文字は \ でエスケープする
( ) はキャプチャだけでなく、グループ化にも使われる
(ABC)? は「文字列 ABC があり、または無し」を表す
(?: ) はキャプチャ無しでグループ化する場合に使う
* と + は「貪欲」で最長マッチを返すため、使い方を誤ると思いがけない結果が返る
*? や +? にすると、最短マッチを返す
テキストエディタで重要なテキストを置換する際は、ひとつずつ確認しながら置換する






その３
本記事ではソースコードの「お掃除」や、アプリケーションログの「取捨選択」を通じて、正規表現に関する以下のような知識を学びます。
ここで使った ^ は「行頭」を表すメタ文字です。
文字そのものではなく、マッチした 「位置」 を示すので、こういったメタ文字を特に アンカー と呼びます。
$ は ^ の反対で、「行末」を意味するメタ文字（アンカー）です。
つまり、^ +$ は「行頭から行末までスペースが1文字以上続く」という意味になります。
タブ文字は \t というメタ文字（文字クラス）を使って表現できます。
Rubularに ^[ \t]+$ という正規表現を入力してみましょう。

JavaScript（JS）の場合、^ と $ を意図したとおりにマッチさせるためには m オプション（複数行検索オプション）を付ける必要があります。
下記のコードにある /^[ \t]+$/gm の m がそのオプションです。
（g はグローバルオプションです。こちらは第1回で紹介しました。）

行末の無駄なスペースは [ \t]+$ という正規表現で抜き出せます。
とはいえ、こういった無駄な空白文字の削除はIDEやプラグインの類が自動的に処理してくれることが多いので、
実務ではそっちを使った方が便利だと思います。
これはあくまで正規表現のお勉強用と考えてくださいね。

インデントがガタガタになったテキストを左寄せにする
反対に ^[ \t]+ とすれば「行頭からスペースやタブ文字が1文字以上続く」の意味になります。
次のようにインデントがガタガタになったテキストも ^[ \t]+ を使えば簡単に左寄せできます。

[ \t] の代わりに \s を使ってみる
正規表現には \s というメタ文字があります。
これは半角スペースやタブ文字、改行文字など、目に見えない「空白文字全般」を表す文字クラスです。
なので先ほどの正規表現は次のように書くことも可能です。
:\s*
ただし、\s を使う場合は次のような点に注意してください。
1. \s に含まれる文字が言語や環境によって異なる
まず、言語や環境によって \s に含まれる文字が微妙に異なります（これは \s に限った話ではありませんが）。
次に示すように、Ruby と JavaScript(JS) でも \s の内容が違います。
Rubyの場合 （参考）
\s = [ \t\r\n\f]
JSの場合 （参考）
\s = [ \f\n\r\t\v​\u00a0\u1680​\u180e\u2000​-\u200a​\u2028\u2029\u202f\u205f​\u3000\ufeff]
Rubyの場合は半角スペース（ ）、タブ文字（\t）、改行文字（\n）、復帰文字（\r）、改ページ文字（\f）だけですが、JSの場合は全角スペース（\u3000）のような空白文字も \s に含まれます。
2. \s には改行文字や復帰文字も含まれる
上に示したように、\s には改行文字（\n）や復帰文字（\r）も含まれます。
なので、何も考えずに \s だけを検索して削除すると、改行文字もろとも削除されて、全部の行が1行になってしまいます。
というわけで、意図的に改行文字を削除したいのでなければ、他に文字列やメタ文字を組み合わせるなどして \s に不特定多数の空白文字がマッチしないような正規表現を作りましょう。

カンマ区切りをタブ区切りに、タブ区切りをカンマ区切りに置換する
検索文字列 = , （これは正規表現ではないただの文字）
置換文字列 = \t （これは正規表現のタブ文字）
タブ文字区切りにすると、ExcelやGoogleスプレッドシートにコピペで値を貼り付けられるので便利なんですよね。
逆にタブ区切りからカンマ区切りに変換するのも簡単です。
検索文字列 = \t
置換文字列 = ,

ログから特定の文字を含む行を削除する
こういう場合は | というメタ文字を使います。
ABC|DEF のように書くと、「文字列ABC、または文字列DEF」という OR条件 の意味になります。
実際にはOR条件の範囲を明確にするため、(ABC|DEF) のようにグループ化の ( ) と一緒に使われることが多いです。

行を詰めるということはすなわち「改行文字を削除すること」です。
$ は「行末」を表すメタ文字ですが、このままだと改行文字は含まれません。
$ の代わりに \n(改行文字) を指定してやると、検索結果に改行文字も含まれるようになります。

捕捉：Windows環境とMac/Linux環境の改行コードの違いを考慮する
ご存知の方も多いと思いますが、Windows環境の改行コードはCRLF（\r\n）です。
一方、Mac/Linux環境ではLF（\n）です。

? は「直前の文字が1個、またはゼロ」を意味するメタ文字です。（第2回で紹介しました）

コラム：使われる場所によって役割が異なる ^ を理解する
[^AB] のような使い方をするときの ^ です。
[ ] の中で ^ が使われると「AでもなくBでもない文字1文字」というふうに [ ] の意味を否定条件に変えるのでした。
もっというと、[AB^] にするとさらに意味が変わります。
これは「AまたはBまたは^のいずれか1文字」の意味になります。
否定条件になるのは [ ] の先頭に ^ が来たときだけです。

^. にすれば「行頭にくる任意の1文字

"^" という文字だけを検索したい場合は \^ というようにバックスラッシュを付けてエスケープしてやります。


まとめ
^ は行頭を表す
$ は行末を表す
\t はタブ文字を表す
\n は改行文字を表す
\s は空白文字（スペース、タブ文字、改行文字等）を表す
ABC|DEF は「文字列ABCまたは文字列DEF」のOR条件を表す
改行コードは環境によって異なる場合がある
^ は行頭の意味になったり、[^ ] で否定の文字クラスの意味になったりする




その４
単語をきれいに取り出す
\b というメタ文字です。これは「単語の境界」を表します。（位置を示すので アンカー の一種です）
単語の境界とはスペースだったり、ピリオドだったり、ダブルクオートだったり、行頭や行末だったり、様々です。
これらはスペース文字やピリオドにマッチしているのではなく、あくまで単語の直前や直後という 位置 にマッチしています。
\b単語\b とすることで、単語がきれいに取り出せる


検索性の低いメソッドをきれいに抜き出す（\b の使い方・その２）
こんなふうに \b を使うと、ソースコードから特定のメソッドや変数を検索したりするときに役立つことがあります。

ファイル名だけをピタリと抜き出す（肯定の後読み）
一般に (?<=abc) のように書くと "abc" という文字列そのものではなく、
その文字列の「直後の位置」（abc であれば c の直後）にマッチします。
これを （肯定の）後読み と言います。

後読みや先読みを使うと便利なのは、Rubyの scan メソッドや、JavaScriptの match メソッドを使うときです。
Rubyの場合、先ほどの文字列から "users.zip" と "posts.xml" を抜き出したいと思ったら、次のようにして一発で抜き出すことができます。

注意：JavaScript や Atom では「後読み」が使えません

特定の楽器を担当しているメンバーを抜き出す（肯定の先読み）
「先読み」のテクニックを使います。
まず、(?=:bass) という正規表現を入力してみてください。
一般に (?=abc) のように書くと "abc" という文字列そのものではなく、
その文字列の「直前の位置」（abc であれば a の直前）にマッチします。
これを （肯定の）先読み と言います。

JS や Atom でも使えます。

間違った都道府県名を見つける（否定の後読み）
一般に (?<!abc) のように書くと "abc" という文字列 以外 の「直後の位置」にマッチします。
これを 否定の後読み と言います。

 「否定の後読み」も JS や Atom では使えません。

「食べ物のサザエ」を見つける（否定の先読み）
一般に (?!abc) のように書くと "abc" という文字列 以外 の「直前の位置」にマッチします。
これを 否定の先読み と言います。

「肯定の先読み」と同様、 「否定の先読み」は JS や Atom でも使えます。

URLがそのまま画面上に表示されているリンクを見つける（後方参照）
第2回の記事では ( ) を使って文字列をキャプチャし、置換するときに \1 や $1 といった連番で参照する、というテクニックを紹介しました。
これは置換するときでなく、正規表現の内部でも同じように参照することができます。
これを 後方参照 といいます。

<a href="(.+?)">\1<\/a>
正規表現内で使われている \1 に注目してください。
これは「( ) でキャプチャされた1番目の文字列」を表しています。
つまり、(.+?) と \1 は同じ文字列を指すことになります。

ツイート、アカウント、ツイート日時を抽出する（メタ文字の複雑な組み合わせ）
(?:\d+ )? の部分が「数字あり、またはなし」の正規表現です。
「直前の文字が1個、またはゼロ」を表す ? は ( ) の後ろに置くと、「カッコに囲まれた文字列が1個、またはゼロ」の意味になります。
( ) の後ろに置ける量指定子は ? だけではありません。
+ や * も ( ) の後ろに置くことができます。
これは今回初めて紹介した内容なのでぜひ覚えておきましょう。

秒、分、時間の場合 = (\d+[smh])
1日以上前、1年以上前の場合 = ((?:\d+ )?[A-Z][a-z]{2} \d+)

ツイート = ^(.*) -  「行頭からハイフンまでの任意の文字列」
アカウント = (@\w+) 「"@" で始まり、任意のアルファベットが続く文字列」
ツイート日時 = (\d+[smh]|(?:\d+ )?[A-Z][a-z]{2} \d+).  「数字 + s/m/h」OR条件「アルファベット3文字 + 数字」=>「数字（アルファベットの前に）数字あり、またはなし + アルファベット3文字 + 数字」
では、正規表現を連結します。

^(.*) - (@\w+) (\d+[smh]|(?:\d+ )?[A-Z][a-z]{2} \d+)

【重要】正規表現とパフォーマンス
正規表現が遅くなる技術的な説明や、問題を起こす正規表現の具体例をもっと知りたい人は、
正規表現 パフォーマンス
正規表現 遅い
正規表現 バックトラック
ツールを使ってパフォーマンスの善し悪しを確認する
(_+|\w+)*a のように、+ や * が ( ) の中にも外にも出てくる正規表現は危険です。
言語や環境を問わず、十分参考になると思います。
なぜなら、大半の正規表現エンジンは NFA（Non determistic Finite Automaton）と呼ばれる仕組みを使っており、動作原理はどれもほぼ同じだからです。
[ ] はそのまま使うとメタ文字になりますが、\[ \] とバックスラッシュでエスケープしてやると、純粋に "[ ]" という文字にマッチするようになります。
これはその他のメタ文字（特別扱いされる文字）についても同様です。
拡張子付きのファイル名を検索するときは \w+\.\w{1,3} のようにピリオドを忘れずにエスケープしてくださいね！

このテキストに対して [()$.*+?|{}] という正規表現を入力してみましょう。
すると、メタ文字の働きが消え、「ただの文字」として各種記号にマッチしているのがわかると思います。
一方、[\w\d\s\n] と書いた場合は「英単語を構成する文字、または半角数字、または空白文字、または改行文字のいずれか1文字」の意味になり、メタ文字としての働きを保ったままになります。
以下はその実行結果です。

さて、特殊なのは - と ^ です。
過去の記事でも説明しましたが、これは [ ] 内の位置によって意味が変わります。
[a-z] と書いた場合は「"a" または "b" ・・・　または "z" のいずれか1文字」の意味になります。（文字の範囲を表す）
しかし、[-az] や [az-] と書いた場合は「"a" または "z" または "-" のいずれか1文字」の意味になります。
[^abc] は「"a" でもなく "b" でもなく "c" でもない任意の1文字」の意味になります。（否定条件を表す）
しかし、[abc^] のように先頭以外の場所に ^ を書いた場合は「"a" または "b" または "c" または "^" のいずれか1文字」の意味になります。

おまけ：[\b] はバックスペース文字を表す

本記事の前半で「単語の境界」を表す \b というメタ文字を紹介しました。
これを [ ] の中に含めて [\b] のように書くと、単語の境界ではなく「バックスペース文字（0x08）」として扱われます。
・・・が、バックスペース文字を検索する機会は滅多にないと思うので、覚える必要はないでしょう。
（少なくとも僕は必要になったことがないです）


「n 個以上」や「n 個以下」を指定する
第1回の記事では {n} や {n,m} で「直前の文字が n 個」や「直前の文字が n 個以上 m 個以下」としていするパターンを説明しました。
そのバリエーションで {n,} や {,n} という書き方があります。
これはそれぞれ「直前の文字が n 個以上」と「直前の文字が n 個以下」の意味になります。
go{4,}gle という正規表現を入力すると、「"o" が4文字以上」の場合にマッチします。
go{,3}gle を入力すると、「"o" が3文字以下」の場合にマッチします。


小文字とは逆の意味になる \W \S \D \B
これまでに \w、\d、\s、\b というメタ文字を紹介しました。
正規表現にはこれと逆の意味になる \W、\D、\S、\B が存在します。
それぞれのメタ文字の意味は以下の通りです。
\W = 英単語の構成文字以外（記号や空白文字など）
\D = 半角数字以外
\S = 空白文字以外
\B = 単語の境界以外の位置


まとめ
本記事では以下のようなことを学びました。

\b は単語の境界を表す
(?=abc) は「abcという文字列の直前の位置」を表す（先読み）
(?<=abc) 「abcという文字列の直後の位置」を表す（後読み）
(?!abc) は「abcという文字列以外の直前の位置」を表す（否定の先読み）
(?<!abc) 「abcという文字列以外の直後の位置」を表す（否定の後読み）
キャプチャした文字列は正規表現内でも \1 や \2 といった連番で参照できる（後方参照）
? や *、+ といった量指定子は ( ) の後ろに付けることもできる
| を使ったOR条件では、各条件内でもメタ文字が使える
書き方によっては、とんでもなく遅い正規表現ができあがることもある
メタ文字はバックスラッシュ（\）でエスケープする
[ ] 内ではメタ文字の種類や使われる位置によって各文字の働きが異なる
{n,} や {,n} はそれぞれ「直前の文字がn個以上」「n個以下」の意味になる
\W、\S、\D、\B はそれぞれ \w、\s、\d、\b の逆の意味になる
